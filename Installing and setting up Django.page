---
format: markdown
categories: technical-notes
...
Sources
=======
* [`virtualenv` docs](http://www.virtualenv.org/en/latest/)
* [`virtualenvwrapper` docs](http://virtualenvwrapper.readthedocs.org/en/latest/)

~~Install Python 3~~
====================

~~This is a new project, and Python 3 is now well supported,
so it seems appropriate to use Python 3.~~ Don't do this.
Most Django apps are Python 2 only.  (But if I do want to,
use `export VIRTUALENV_PYTHON=/usr/local/bin/python3`)

    brew install python3

added Python 3.3.3 to my system.

I can launch Python 3 with the command `python3`, and the Python 3 package manager with `pip3`.

Install and configure `virtualenv` and `virtualenvwrapper`
==========================================================

    pip install virtualenvwrapper

I used pip, rather than pip3, because Python 2 is the default Python for my system.  `virtualenv` will run under Python 2, but it has no problem creating a Python 3 environment.

Create a directory for my virtual environments and associated projects, and tell `virtualenvwrapper` about them:

    mkdir ~/Python
    mkdir ~/VirtualEnvironments
    mkdir ~/Projects

**Don't** add this.  Python 3 is not as well supported as I thought.

    # tell virtualenv I want to use python3, rather than the default python installation
    export VIRTUALENV_PYTHON=/usr/local/bin/python3

And add this to `~/.bash_profile`:

    # tell virtualenvwrapper which directories I want to use
    export WORKON_HOME=~/Python/VirtualEnvironments
    export PROJECT_HOME=~/Python/Projects

    # make virtualenvwrapper load lazily
    export VIRUALENVWRAPPER_SCRIPT=/usr/local/bin/virtualenvwrapper.sh
    source /usr/local/bin/virtualenvwrapper_lazy.sh

(Lazy loading means that tab completion for `virtualenvwrapper` commands
will only work after I've run a command once.)

Create a Python 3 Django environment
====================================

Since I've set the `VIRTUALENV_PYTHON` variable to point at Python 3,
pip3 and Python 3 will be used by default.

    mkvirtualenv django
    workon django

Now I'm in an environment where `python` is bound to Python 3.
Install Django in this environment:

    pip install django

Now I can enter that environment with the `workon django` command.

Create a project
================

Create a duplicate of the django environment for the project. Enter that environment:

    cpvirtualenv django project_name
    workon project_name

The book *Two Scoops of Django* recommends that I nest my Django project folder
in another folder. This also seems to help with things like heroku integration.
I want the folder to also exist in my dropbox, so I'll actually create it as
a symlink.

So first, create and symlink the folder. I'll call it *ranran*:

    cd ~/Python/Projects
    mkdir ~/Dropbox/final_project/code/ranran
    ln -s ~/Dropbox/final_project_code_ranran

Tell `virtualenvwrapper` about it:

    cd ~/Python/project/ranran
    setvirtualenvproject

Now `cdproject`, `cdsitepackages` and `cdvirtualenv` will take me to the relevant directories.

(Any number of virtual environments can refer to the same project. This means we can unit-test a project in mutliple environments.)

Now create the django project:

    cdproject
    djangoadmin.py startproject ranran

I now have the following directory structure for my project:

    ranran/
      manage.py
      ranran/
        __init__.py
        settings.py
        urls.py
        wsgi.py

The root directory is where I can put the deployment files.
`docs/`, `.gitignore` and the `requirements.txt` generated by `pip freeze` can all go here.

I also need to make directories for static content (`ranran/ranran/static/`)
and sitewide templates (`ranran/ranran/templates`).

To leave the virtual environment, say `deactivate`.